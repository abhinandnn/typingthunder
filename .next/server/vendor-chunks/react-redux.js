"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-redux";
exports.ids = ["vendor-chunks/react-redux"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-redux/dist/react-redux.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-redux/dist/react-redux.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider_default),\n/* harmony export */   ReactReduxContext: () => (/* binding */ ReactReduxContext),\n/* harmony export */   batch: () => (/* binding */ batch),\n/* harmony export */   connect: () => (/* binding */ connect_default),\n/* harmony export */   createDispatchHook: () => (/* binding */ createDispatchHook),\n/* harmony export */   createSelectorHook: () => (/* binding */ createSelectorHook),\n/* harmony export */   createStoreHook: () => (/* binding */ createStoreHook),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   useDispatch: () => (/* binding */ useDispatch),\n/* harmony export */   useSelector: () => (/* binding */ useSelector),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/with-selector.js */ \"(ssr)/./node_modules/use-sync-external-store/with-selector.js\");\n// src/index.ts\n\n\n// src/utils/react.ts\n\nvar React = // prettier-ignore\n// @ts-ignore\n true ? react__WEBPACK_IMPORTED_MODULE_0__ : /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)));\n// src/components/Context.ts\nvar ContextKey = Symbol.for(`react-redux-context`);\nvar gT = typeof globalThis !== \"undefined\" ? globalThis : /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */ {};\nfunction getContext() {\n    if (!React.createContext) return {};\n    const contextMap = gT[ContextKey] ?? (gT[ContextKey] = /* @__PURE__ */ new Map());\n    let realContext = contextMap.get(React.createContext);\n    if (!realContext) {\n        realContext = React.createContext(null);\n        if (true) {\n            realContext.displayName = \"ReactRedux\";\n        }\n        contextMap.set(React.createContext, realContext);\n    }\n    return realContext;\n}\nvar ReactReduxContext = /* @__PURE__ */ getContext();\n// src/utils/useSyncExternalStore.ts\nvar notInitialized = ()=>{\n    throw new Error(\"uSES not initialized!\");\n};\n// src/hooks/useReduxContext.ts\nfunction createReduxContextHook(context = ReactReduxContext) {\n    return function useReduxContext2() {\n        const contextValue = React.useContext(context);\n        if ( true && !contextValue) {\n            throw new Error(\"could not find react-redux context value; please ensure the component is wrapped in a <Provider>\");\n        }\n        return contextValue;\n    };\n}\nvar useReduxContext = /* @__PURE__ */ createReduxContextHook();\n// src/hooks/useSelector.ts\nvar useSyncExternalStoreWithSelector = notInitialized;\nvar initializeUseSelector = (fn)=>{\n    useSyncExternalStoreWithSelector = fn;\n};\nvar refEquality = (a, b)=>a === b;\nfunction createSelectorHook(context = ReactReduxContext) {\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);\n    const useSelector2 = (selector, equalityFnOrOptions = {})=>{\n        const { equalityFn = refEquality, devModeChecks = {} } = typeof equalityFnOrOptions === \"function\" ? {\n            equalityFn: equalityFnOrOptions\n        } : equalityFnOrOptions;\n        if (true) {\n            if (!selector) {\n                throw new Error(`You must pass a selector to useSelector`);\n            }\n            if (typeof selector !== \"function\") {\n                throw new Error(`You must pass a function as a selector to useSelector`);\n            }\n            if (typeof equalityFn !== \"function\") {\n                throw new Error(`You must pass a function as an equality function to useSelector`);\n            }\n        }\n        const { store, subscription, getServerState, stabilityCheck, identityFunctionCheck } = useReduxContext2();\n        const firstRun = React.useRef(true);\n        const wrappedSelector = React.useCallback({\n            [selector.name] (state) {\n                const selected = selector(state);\n                if (true) {\n                    const { identityFunctionCheck: finalIdentityFunctionCheck, stabilityCheck: finalStabilityCheck } = {\n                        stabilityCheck,\n                        identityFunctionCheck,\n                        ...devModeChecks\n                    };\n                    if (finalStabilityCheck === \"always\" || finalStabilityCheck === \"once\" && firstRun.current) {\n                        const toCompare = selector(state);\n                        if (!equalityFn(selected, toCompare)) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned a different result when called with the same parameters. This can lead to unnecessary rerenders.\\nSelectors that return a new reference (such as an object or an array) should be memoized: https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization\", {\n                                state,\n                                selected,\n                                selected2: toCompare,\n                                stack\n                            });\n                        }\n                    }\n                    if (finalIdentityFunctionCheck === \"always\" || finalIdentityFunctionCheck === \"once\" && firstRun.current) {\n                        if (selected === state) {\n                            let stack = void 0;\n                            try {\n                                throw new Error();\n                            } catch (e) {\n                                ;\n                                ({ stack } = e);\n                            }\n                            console.warn(\"Selector \" + (selector.name || \"unknown\") + \" returned the root state when called. This can lead to unnecessary rerenders.\\nSelectors that return the entire state are almost certainly a mistake, as they will cause a rerender whenever *anything* in state changes.\", {\n                                stack\n                            });\n                        }\n                    }\n                    if (firstRun.current) firstRun.current = false;\n                }\n                return selected;\n            }\n        }[selector.name], [\n            selector,\n            stabilityCheck,\n            devModeChecks.stabilityCheck\n        ]);\n        const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);\n        React.useDebugValue(selectedState);\n        return selectedState;\n    };\n    Object.assign(useSelector2, {\n        withTypes: ()=>useSelector2\n    });\n    return useSelector2;\n}\nvar useSelector = /* @__PURE__ */ createSelectorHook();\n// src/utils/react-is.ts\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\nvar REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\nvar REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\nvar REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\nvar REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\nvar REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\nvar REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for(\"react.server_context\");\nvar REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\nvar REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\nvar REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\nvar REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\nvar REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nfunction isValidElementType(type) {\n    if (typeof type === \"string\" || typeof type === \"function\") {\n        return true;\n    }\n    if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE) {\n        return true;\n    }\n    if (typeof type === \"object\" && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_CLIENT_REFERENCE || type.getModuleId !== void 0) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction typeOf(object) {\n    if (typeof object === \"object\" && object !== null) {\n        const $$typeof = object.$$typeof;\n        switch($$typeof){\n            case REACT_ELEMENT_TYPE:\n                {\n                    const type = object.type;\n                    switch(type){\n                        case REACT_FRAGMENT_TYPE:\n                        case REACT_PROFILER_TYPE:\n                        case REACT_STRICT_MODE_TYPE:\n                        case REACT_SUSPENSE_TYPE:\n                        case REACT_SUSPENSE_LIST_TYPE:\n                            return type;\n                        default:\n                            {\n                                const $$typeofType = type && type.$$typeof;\n                                switch($$typeofType){\n                                    case REACT_SERVER_CONTEXT_TYPE:\n                                    case REACT_CONTEXT_TYPE:\n                                    case REACT_FORWARD_REF_TYPE:\n                                    case REACT_LAZY_TYPE:\n                                    case REACT_MEMO_TYPE:\n                                    case REACT_PROVIDER_TYPE:\n                                        return $$typeofType;\n                                    default:\n                                        return $$typeof;\n                                }\n                            }\n                    }\n                }\n            case REACT_PORTAL_TYPE:\n                {\n                    return $$typeof;\n                }\n        }\n    }\n    return void 0;\n}\nfunction isContextConsumer(object) {\n    return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isMemo(object) {\n    return typeOf(object) === REACT_MEMO_TYPE;\n}\n// src/utils/warning.ts\nfunction warning(message) {\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n        console.error(message);\n    }\n    try {\n        throw new Error(message);\n    } catch (e) {}\n}\n// src/connect/verifySubselectors.ts\nfunction verify(selector, methodName) {\n    if (!selector) {\n        throw new Error(`Unexpected value for ${methodName} in connect.`);\n    } else if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\n        if (!Object.prototype.hasOwnProperty.call(selector, \"dependsOnOwnProps\")) {\n            warning(`The selector for ${methodName} of connect did not specify a value for dependsOnOwnProps.`);\n        }\n    }\n}\nfunction verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps) {\n    verify(mapStateToProps, \"mapStateToProps\");\n    verify(mapDispatchToProps, \"mapDispatchToProps\");\n    verify(mergeProps, \"mergeProps\");\n}\n// src/connect/selectorFactory.ts\nfunction pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, { areStatesEqual, areOwnPropsEqual, areStatePropsEqual }) {\n    let hasRunAtLeastOnce = false;\n    let state;\n    let ownProps;\n    let stateProps;\n    let dispatchProps;\n    let mergedProps;\n    function handleFirstCall(firstState, firstOwnProps) {\n        state = firstState;\n        ownProps = firstOwnProps;\n        stateProps = mapStateToProps(state, ownProps);\n        dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        hasRunAtLeastOnce = true;\n        return mergedProps;\n    }\n    function handleNewPropsAndNewState() {\n        stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewProps() {\n        if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);\n        if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleNewState() {\n        const nextStateProps = mapStateToProps(state, ownProps);\n        const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\n        stateProps = nextStateProps;\n        if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n        return mergedProps;\n    }\n    function handleSubsequentCalls(nextState, nextOwnProps) {\n        const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\n        const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);\n        state = nextState;\n        ownProps = nextOwnProps;\n        if (propsChanged && stateChanged) return handleNewPropsAndNewState();\n        if (propsChanged) return handleNewProps();\n        if (stateChanged) return handleNewState();\n        return mergedProps;\n    }\n    return function pureFinalPropsSelector(nextState, nextOwnProps) {\n        return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);\n    };\n}\nfunction finalPropsSelectorFactory(dispatch, { initMapStateToProps, initMapDispatchToProps, initMergeProps, ...options }) {\n    const mapStateToProps = initMapStateToProps(dispatch, options);\n    const mapDispatchToProps = initMapDispatchToProps(dispatch, options);\n    const mergeProps = initMergeProps(dispatch, options);\n    if (true) {\n        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps);\n    }\n    return pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\n}\n// src/utils/bindActionCreators.ts\nfunction bindActionCreators(actionCreators, dispatch) {\n    const boundActionCreators = {};\n    for(const key in actionCreators){\n        const actionCreator = actionCreators[key];\n        if (typeof actionCreator === \"function\") {\n            boundActionCreators[key] = (...args)=>dispatch(actionCreator(...args));\n        }\n    }\n    return boundActionCreators;\n}\n// src/utils/isPlainObject.ts\nfunction isPlainObject(obj) {\n    if (typeof obj !== \"object\" || obj === null) return false;\n    const proto = Object.getPrototypeOf(obj);\n    if (proto === null) return true;\n    let baseProto = proto;\n    while(Object.getPrototypeOf(baseProto) !== null){\n        baseProto = Object.getPrototypeOf(baseProto);\n    }\n    return proto === baseProto;\n}\n// src/utils/verifyPlainObject.ts\nfunction verifyPlainObject(value, displayName, methodName) {\n    if (!isPlainObject(value)) {\n        warning(`${methodName}() in ${displayName} must return a plain object. Instead received ${value}.`);\n    }\n}\n// src/connect/wrapMapToProps.ts\nfunction wrapMapToPropsConstant(getConstant) {\n    return function initConstantSelector(dispatch) {\n        const constant = getConstant(dispatch);\n        function constantSelector() {\n            return constant;\n        }\n        constantSelector.dependsOnOwnProps = false;\n        return constantSelector;\n    };\n}\nfunction getDependsOnOwnProps(mapToProps) {\n    return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;\n}\nfunction wrapMapToPropsFunc(mapToProps, methodName) {\n    return function initProxySelector(dispatch, { displayName }) {\n        const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {\n            return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);\n        };\n        proxy.dependsOnOwnProps = true;\n        proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {\n            proxy.mapToProps = mapToProps;\n            proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\n            let props = proxy(stateOrDispatch, ownProps);\n            if (typeof props === \"function\") {\n                proxy.mapToProps = props;\n                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\n                props = proxy(stateOrDispatch, ownProps);\n            }\n            if (true) verifyPlainObject(props, displayName, methodName);\n            return props;\n        };\n        return proxy;\n    };\n}\n// src/connect/invalidArgFactory.ts\nfunction createInvalidArgFactory(arg, name) {\n    return (dispatch, options)=>{\n        throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);\n    };\n}\n// src/connect/mapDispatchToProps.ts\nfunction mapDispatchToPropsFactory(mapDispatchToProps) {\n    return mapDispatchToProps && typeof mapDispatchToProps === \"object\" ? wrapMapToPropsConstant((dispatch)=>// @ts-ignore\n        bindActionCreators(mapDispatchToProps, dispatch)) : !mapDispatchToProps ? wrapMapToPropsConstant((dispatch)=>({\n            dispatch\n        })) : typeof mapDispatchToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\") : createInvalidArgFactory(mapDispatchToProps, \"mapDispatchToProps\");\n}\n// src/connect/mapStateToProps.ts\nfunction mapStateToPropsFactory(mapStateToProps) {\n    return !mapStateToProps ? wrapMapToPropsConstant(()=>({})) : typeof mapStateToProps === \"function\" ? // @ts-ignore\n    wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\") : createInvalidArgFactory(mapStateToProps, \"mapStateToProps\");\n}\n// src/connect/mergeProps.ts\nfunction defaultMergeProps(stateProps, dispatchProps, ownProps) {\n    return {\n        ...ownProps,\n        ...stateProps,\n        ...dispatchProps\n    };\n}\nfunction wrapMergePropsFunc(mergeProps) {\n    return function initMergePropsProxy(dispatch, { displayName, areMergedPropsEqual }) {\n        let hasRunOnce = false;\n        let mergedProps;\n        return function mergePropsProxy(stateProps, dispatchProps, ownProps) {\n            const nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\n            if (hasRunOnce) {\n                if (!areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;\n            } else {\n                hasRunOnce = true;\n                mergedProps = nextMergedProps;\n                if (true) verifyPlainObject(mergedProps, displayName, \"mergeProps\");\n            }\n            return mergedProps;\n        };\n    };\n}\nfunction mergePropsFactory(mergeProps) {\n    return !mergeProps ? ()=>defaultMergeProps : typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : createInvalidArgFactory(mergeProps, \"mergeProps\");\n}\n// src/utils/batch.ts\nfunction defaultNoopBatch(callback) {\n    callback();\n}\n// src/utils/Subscription.ts\nfunction createListenerCollection() {\n    let first = null;\n    let last = null;\n    return {\n        clear () {\n            first = null;\n            last = null;\n        },\n        notify () {\n            defaultNoopBatch(()=>{\n                let listener = first;\n                while(listener){\n                    listener.callback();\n                    listener = listener.next;\n                }\n            });\n        },\n        get () {\n            const listeners = [];\n            let listener = first;\n            while(listener){\n                listeners.push(listener);\n                listener = listener.next;\n            }\n            return listeners;\n        },\n        subscribe (callback) {\n            let isSubscribed = true;\n            const listener = last = {\n                callback,\n                next: null,\n                prev: last\n            };\n            if (listener.prev) {\n                listener.prev.next = listener;\n            } else {\n                first = listener;\n            }\n            return function unsubscribe() {\n                if (!isSubscribed || first === null) return;\n                isSubscribed = false;\n                if (listener.next) {\n                    listener.next.prev = listener.prev;\n                } else {\n                    last = listener.prev;\n                }\n                if (listener.prev) {\n                    listener.prev.next = listener.next;\n                } else {\n                    first = listener.next;\n                }\n            };\n        }\n    };\n}\nvar nullListeners = {\n    notify () {},\n    get: ()=>[]\n};\nfunction createSubscription(store, parentSub) {\n    let unsubscribe;\n    let listeners = nullListeners;\n    let subscriptionsAmount = 0;\n    let selfSubscribed = false;\n    function addNestedSub(listener) {\n        trySubscribe();\n        const cleanupListener = listeners.subscribe(listener);\n        let removed = false;\n        return ()=>{\n            if (!removed) {\n                removed = true;\n                cleanupListener();\n                tryUnsubscribe();\n            }\n        };\n    }\n    function notifyNestedSubs() {\n        listeners.notify();\n    }\n    function handleChangeWrapper() {\n        if (subscription.onStateChange) {\n            subscription.onStateChange();\n        }\n    }\n    function isSubscribed() {\n        return selfSubscribed;\n    }\n    function trySubscribe() {\n        subscriptionsAmount++;\n        if (!unsubscribe) {\n            unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);\n            listeners = createListenerCollection();\n        }\n    }\n    function tryUnsubscribe() {\n        subscriptionsAmount--;\n        if (unsubscribe && subscriptionsAmount === 0) {\n            unsubscribe();\n            unsubscribe = void 0;\n            listeners.clear();\n            listeners = nullListeners;\n        }\n    }\n    function trySubscribeSelf() {\n        if (!selfSubscribed) {\n            selfSubscribed = true;\n            trySubscribe();\n        }\n    }\n    function tryUnsubscribeSelf() {\n        if (selfSubscribed) {\n            selfSubscribed = false;\n            tryUnsubscribe();\n        }\n    }\n    const subscription = {\n        addNestedSub,\n        notifyNestedSubs,\n        handleChangeWrapper,\n        isSubscribed,\n        trySubscribe: trySubscribeSelf,\n        tryUnsubscribe: tryUnsubscribeSelf,\n        getListeners: ()=>listeners\n    };\n    return subscription;\n}\n// src/utils/useIsomorphicLayoutEffect.ts\nvar canUseDOM = !!( false && 0);\nvar useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect;\n// src/utils/shallowEqual.ts\nfunction is(x, y) {\n    if (x === y) {\n        return x !== 0 || y !== 0 || 1 / x === 1 / y;\n    } else {\n        return x !== x && y !== y;\n    }\n}\nfunction shallowEqual(objA, objB) {\n    if (is(objA, objB)) return true;\n    if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n        return false;\n    }\n    const keysA = Object.keys(objA);\n    const keysB = Object.keys(objB);\n    if (keysA.length !== keysB.length) return false;\n    for(let i = 0; i < keysA.length; i++){\n        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\n// src/utils/hoistStatics.ts\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextType: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromError: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar FORWARD_REF_STATICS = {\n    $$typeof: true,\n    render: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true\n};\nvar MEMO_STATICS = {\n    $$typeof: true,\n    compare: true,\n    defaultProps: true,\n    displayName: true,\n    propTypes: true,\n    type: true\n};\nvar TYPE_STATICS = {\n    [ForwardRef]: FORWARD_REF_STATICS,\n    [Memo]: MEMO_STATICS\n};\nfunction getStatics(component) {\n    if (isMemo(component)) {\n        return MEMO_STATICS;\n    }\n    return TYPE_STATICS[component[\"$$typeof\"]] || REACT_STATICS;\n}\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = Object.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent) {\n    if (typeof sourceComponent !== \"string\") {\n        if (objectPrototype) {\n            const inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent);\n            }\n        }\n        let keys = getOwnPropertyNames(sourceComponent);\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n        const targetStatics = getStatics(targetComponent);\n        const sourceStatics = getStatics(sourceComponent);\n        for(let i = 0; i < keys.length; ++i){\n            const key = keys[i];\n            if (!KNOWN_STATICS[key] && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {\n                const descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try {\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n    }\n    return targetComponent;\n}\n// src/components/connect.tsx\nvar useSyncExternalStore = notInitialized;\nvar initializeConnect = (fn)=>{\n    useSyncExternalStore = fn;\n};\nvar NO_SUBSCRIPTION_ARRAY = [\n    null,\n    null\n];\nvar stringifyComponent = (Comp)=>{\n    try {\n        return JSON.stringify(Comp);\n    } catch (err) {\n        return String(Comp);\n    }\n};\nfunction useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {\n    useIsomorphicLayoutEffect(()=>effectFunc(...effectArgs), dependencies);\n}\nfunction captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {\n    lastWrapperProps.current = wrapperProps;\n    renderIsScheduled.current = false;\n    if (childPropsFromStoreUpdate.current) {\n        childPropsFromStoreUpdate.current = null;\n        notifyNestedSubs();\n    }\n}\nfunction subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {\n    if (!shouldHandleStateChanges) return ()=>{};\n    let didUnsubscribe = false;\n    let lastThrownError = null;\n    const checkForUpdates = ()=>{\n        if (didUnsubscribe || !isMounted.current) {\n            return;\n        }\n        const latestStoreState = store.getState();\n        let newChildProps, error;\n        try {\n            newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);\n        } catch (e) {\n            error = e;\n            lastThrownError = e;\n        }\n        if (!error) {\n            lastThrownError = null;\n        }\n        if (newChildProps === lastChildProps.current) {\n            if (!renderIsScheduled.current) {\n                notifyNestedSubs();\n            }\n        } else {\n            lastChildProps.current = newChildProps;\n            childPropsFromStoreUpdate.current = newChildProps;\n            renderIsScheduled.current = true;\n            additionalSubscribeListener();\n        }\n    };\n    subscription.onStateChange = checkForUpdates;\n    subscription.trySubscribe();\n    checkForUpdates();\n    const unsubscribeWrapper = ()=>{\n        didUnsubscribe = true;\n        subscription.tryUnsubscribe();\n        subscription.onStateChange = null;\n        if (lastThrownError) {\n            throw lastThrownError;\n        }\n    };\n    return unsubscribeWrapper;\n}\nfunction strictEqual(a, b) {\n    return a === b;\n}\nvar hasWarnedAboutDeprecatedPureOption = false;\nfunction connect(mapStateToProps, mapDispatchToProps, mergeProps, { // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.\n// @ts-ignore\npure, areStatesEqual = strictEqual, areOwnPropsEqual = shallowEqual, areStatePropsEqual = shallowEqual, areMergedPropsEqual = shallowEqual, // use React's forwardRef to expose a ref of the wrapped component\nforwardRef = false, // the context consumer to use\ncontext = ReactReduxContext } = {}) {\n    if (true) {\n        if (pure !== void 0 && !hasWarnedAboutDeprecatedPureOption) {\n            hasWarnedAboutDeprecatedPureOption = true;\n            warning('The `pure` option has been removed. `connect` is now always a \"pure/memoized\" component');\n        }\n    }\n    const Context = context;\n    const initMapStateToProps = mapStateToPropsFactory(mapStateToProps);\n    const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps);\n    const initMergeProps = mergePropsFactory(mergeProps);\n    const shouldHandleStateChanges = Boolean(mapStateToProps);\n    const wrapWithConnect = (WrappedComponent)=>{\n        if (true) {\n            const isValid = /* @__PURE__ */ isValidElementType(WrappedComponent);\n            if (!isValid) throw new Error(`You must pass a component to the function returned by connect. Instead received ${stringifyComponent(WrappedComponent)}`);\n        }\n        const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \"Component\";\n        const displayName = `Connect(${wrappedComponentName})`;\n        const selectorFactoryOptions = {\n            shouldHandleStateChanges,\n            displayName,\n            wrappedComponentName,\n            WrappedComponent,\n            // @ts-ignore\n            initMapStateToProps,\n            // @ts-ignore\n            initMapDispatchToProps,\n            initMergeProps,\n            areStatesEqual,\n            areStatePropsEqual,\n            areOwnPropsEqual,\n            areMergedPropsEqual\n        };\n        function ConnectFunction(props) {\n            const [propsContext, reactReduxForwardedRef, wrapperProps] = React.useMemo(()=>{\n                const { reactReduxForwardedRef: reactReduxForwardedRef2, ...wrapperProps2 } = props;\n                return [\n                    props.context,\n                    reactReduxForwardedRef2,\n                    wrapperProps2\n                ];\n            }, [\n                props\n            ]);\n            const ContextToUse = React.useMemo(()=>{\n                let ResultContext = Context;\n                if (propsContext?.Consumer) {\n                    if (true) {\n                        const isValid = /* @__PURE__ */ isContextConsumer(// @ts-ignore\n                        /* @__PURE__ */ React.createElement(propsContext.Consumer, null));\n                        if (!isValid) {\n                            throw new Error(\"You must pass a valid React context consumer as `props.context`\");\n                        }\n                        ResultContext = propsContext;\n                    }\n                }\n                return ResultContext;\n            }, [\n                propsContext,\n                Context\n            ]);\n            const contextValue = React.useContext(ContextToUse);\n            const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);\n            const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);\n            if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {\n                throw new Error(`Could not find \"store\" in the context of \"${displayName}\". Either wrap the root component in a <Provider>, or pass a custom React context provider to <Provider> and the corresponding React context consumer to ${displayName} in connect options.`);\n            }\n            const store = didStoreComeFromProps ? props.store : contextValue.store;\n            const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;\n            const childPropsSelector = React.useMemo(()=>{\n                return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);\n            }, [\n                store\n            ]);\n            const [subscription, notifyNestedSubs] = React.useMemo(()=>{\n                if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;\n                const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);\n                const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);\n                return [\n                    subscription2,\n                    notifyNestedSubs2\n                ];\n            }, [\n                store,\n                didStoreComeFromProps,\n                contextValue\n            ]);\n            const overriddenContextValue = React.useMemo(()=>{\n                if (didStoreComeFromProps) {\n                    return contextValue;\n                }\n                return {\n                    ...contextValue,\n                    subscription\n                };\n            }, [\n                didStoreComeFromProps,\n                contextValue,\n                subscription\n            ]);\n            const lastChildProps = React.useRef();\n            const lastWrapperProps = React.useRef(wrapperProps);\n            const childPropsFromStoreUpdate = React.useRef();\n            const renderIsScheduled = React.useRef(false);\n            const isProcessingDispatch = React.useRef(false);\n            const isMounted = React.useRef(false);\n            const latestSubscriptionCallbackError = React.useRef();\n            useIsomorphicLayoutEffect(()=>{\n                isMounted.current = true;\n                return ()=>{\n                    isMounted.current = false;\n                };\n            }, []);\n            const actualChildPropsSelector = React.useMemo(()=>{\n                const selector = ()=>{\n                    if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {\n                        return childPropsFromStoreUpdate.current;\n                    }\n                    return childPropsSelector(store.getState(), wrapperProps);\n                };\n                return selector;\n            }, [\n                store,\n                wrapperProps\n            ]);\n            const subscribeForReact = React.useMemo(()=>{\n                const subscribe = (reactListener)=>{\n                    if (!subscription) {\n                        return ()=>{};\n                    }\n                    return subscribeUpdates(shouldHandleStateChanges, store, subscription, // @ts-ignore\n                    childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, reactListener);\n                };\n                return subscribe;\n            }, [\n                subscription\n            ]);\n            useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [\n                lastWrapperProps,\n                lastChildProps,\n                renderIsScheduled,\n                wrapperProps,\n                childPropsFromStoreUpdate,\n                notifyNestedSubs\n            ]);\n            let actualChildProps;\n            try {\n                actualChildProps = useSyncExternalStore(// TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing\n                subscribeForReact, // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,\n                // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.\n                actualChildPropsSelector, getServerState ? ()=>childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector);\n            } catch (err) {\n                if (latestSubscriptionCallbackError.current) {\n                    ;\n                    err.message += `\nThe error may be correlated with this previous error:\n${latestSubscriptionCallbackError.current.stack}\n\n`;\n                }\n                throw err;\n            }\n            useIsomorphicLayoutEffect(()=>{\n                latestSubscriptionCallbackError.current = void 0;\n                childPropsFromStoreUpdate.current = void 0;\n                lastChildProps.current = actualChildProps;\n            });\n            const renderedWrappedComponent = React.useMemo(()=>{\n                return(// @ts-ignore\n                /* @__PURE__ */ React.createElement(WrappedComponent, {\n                    ...actualChildProps,\n                    ref: reactReduxForwardedRef\n                }));\n            }, [\n                reactReduxForwardedRef,\n                WrappedComponent,\n                actualChildProps\n            ]);\n            const renderedChild = React.useMemo(()=>{\n                if (shouldHandleStateChanges) {\n                    return /* @__PURE__ */ React.createElement(ContextToUse.Provider, {\n                        value: overriddenContextValue\n                    }, renderedWrappedComponent);\n                }\n                return renderedWrappedComponent;\n            }, [\n                ContextToUse,\n                renderedWrappedComponent,\n                overriddenContextValue\n            ]);\n            return renderedChild;\n        }\n        const _Connect = React.memo(ConnectFunction);\n        const Connect = _Connect;\n        Connect.WrappedComponent = WrappedComponent;\n        Connect.displayName = ConnectFunction.displayName = displayName;\n        if (forwardRef) {\n            const _forwarded = React.forwardRef(function forwardConnectRef(props, ref) {\n                return /* @__PURE__ */ React.createElement(Connect, {\n                    ...props,\n                    reactReduxForwardedRef: ref\n                });\n            });\n            const forwarded = _forwarded;\n            forwarded.displayName = displayName;\n            forwarded.WrappedComponent = WrappedComponent;\n            return /* @__PURE__ */ hoistNonReactStatics(forwarded, WrappedComponent);\n        }\n        return /* @__PURE__ */ hoistNonReactStatics(Connect, WrappedComponent);\n    };\n    return wrapWithConnect;\n}\nvar connect_default = connect;\n// src/components/Provider.tsx\nfunction Provider({ store, context, children, serverState, stabilityCheck = \"once\", identityFunctionCheck = \"once\" }) {\n    const contextValue = React.useMemo(()=>{\n        const subscription = createSubscription(store);\n        return {\n            store,\n            subscription,\n            getServerState: serverState ? ()=>serverState : void 0,\n            stabilityCheck,\n            identityFunctionCheck\n        };\n    }, [\n        store,\n        serverState,\n        stabilityCheck,\n        identityFunctionCheck\n    ]);\n    const previousState = React.useMemo(()=>store.getState(), [\n        store\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        const { subscription } = contextValue;\n        subscription.onStateChange = subscription.notifyNestedSubs;\n        subscription.trySubscribe();\n        if (previousState !== store.getState()) {\n            subscription.notifyNestedSubs();\n        }\n        return ()=>{\n            subscription.tryUnsubscribe();\n            subscription.onStateChange = void 0;\n        };\n    }, [\n        contextValue,\n        previousState\n    ]);\n    const Context = context || ReactReduxContext;\n    return /* @__PURE__ */ React.createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\nvar Provider_default = Provider;\n// src/hooks/useStore.ts\nfunction createStoreHook(context = ReactReduxContext) {\n    const useReduxContext2 = context === ReactReduxContext ? useReduxContext : // @ts-ignore\n    createReduxContextHook(context);\n    const useStore2 = ()=>{\n        const { store } = useReduxContext2();\n        return store;\n    };\n    Object.assign(useStore2, {\n        withTypes: ()=>useStore2\n    });\n    return useStore2;\n}\nvar useStore = /* @__PURE__ */ createStoreHook();\n// src/hooks/useDispatch.ts\nfunction createDispatchHook(context = ReactReduxContext) {\n    const useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);\n    const useDispatch2 = ()=>{\n        const store = useStore2();\n        return store.dispatch;\n    };\n    Object.assign(useDispatch2, {\n        withTypes: ()=>useDispatch2\n    });\n    return useDispatch2;\n}\nvar useDispatch = /* @__PURE__ */ createDispatchHook();\n// src/exports.ts\nvar batch = defaultNoopBatch;\n// src/index.ts\ninitializeUseSelector(use_sync_external_store_with_selector_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStoreWithSelector);\ninitializeConnect(react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore);\n //# sourceMappingURL=react-redux.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2lCO0FBQ2lHO0FBRWpJLHFCQUFxQjtBQUNrQjtBQUN2QyxJQUFJSSxRQUNGLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2IsS0FBMEJELEdBQUdBLGtDQUF3QixHQUFHQSx5TEFBYUE7QUFHdkUsNEJBQTRCO0FBQzVCLElBQUlFLGFBQWFDLE9BQU9DLEdBQUcsQ0FBQyxDQUFDLG1CQUFtQixDQUFDO0FBQ2pELElBQUlDLEtBQUssT0FBT0MsZUFBZSxjQUFjQSxhQUMzQyx3RkFBd0YsR0FDeEYsQ0FBQztBQUVILFNBQVNDO0lBQ1AsSUFBSSxDQUFDTixNQUFNTyxhQUFhLEVBQ3RCLE9BQU8sQ0FBQztJQUNWLE1BQU1DLGFBQWFKLEVBQUUsQ0FBQ0gsV0FBVyxJQUFLRyxDQUFBQSxFQUFFLENBQUNILFdBQVcsR0FBRyxhQUFhLEdBQUcsSUFBSVEsS0FBSTtJQUMvRSxJQUFJQyxjQUFjRixXQUFXRyxHQUFHLENBQUNYLE1BQU1PLGFBQWE7SUFDcEQsSUFBSSxDQUFDRyxhQUFhO1FBQ2hCQSxjQUFjVixNQUFNTyxhQUFhLENBQy9CO1FBRUYsSUFBSUssSUFBcUMsRUFBRTtZQUN6Q0YsWUFBWUcsV0FBVyxHQUFHO1FBQzVCO1FBQ0FMLFdBQVdNLEdBQUcsQ0FBQ2QsTUFBTU8sYUFBYSxFQUFFRztJQUN0QztJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJSyxvQkFBb0IsYUFBYSxHQUFHVDtBQUV4QyxvQ0FBb0M7QUFDcEMsSUFBSVUsaUJBQWlCO0lBQ25CLE1BQU0sSUFBSUMsTUFBTTtBQUNsQjtBQUVBLCtCQUErQjtBQUMvQixTQUFTQyx1QkFBdUJDLFVBQVVKLGlCQUFpQjtJQUN6RCxPQUFPLFNBQVNLO1FBQ2QsTUFBTUMsZUFBZXJCLE1BQU1zQixVQUFVLENBQUNIO1FBQ3RDLElBQUlQLEtBQXFDLElB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ZXMvcmVhY3QtcmVkdXgvZGlzdC9yZWFjdC1yZWR1eC5tanM/MDQyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCAqIGFzIFJlYWN0MiBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yMiB9IGZyb20gXCJ1c2Utc3luYy1leHRlcm5hbC1zdG9yZS93aXRoLXNlbGVjdG9yLmpzXCI7XG5cbi8vIHNyYy91dGlscy9yZWFjdC50c1xuaW1wb3J0ICogYXMgUmVhY3RPcmlnaW5hbCBmcm9tIFwicmVhY3RcIjtcbnZhciBSZWFjdCA9IChcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIC8vIEB0cy1pZ25vcmVcbiAgXCJkZWZhdWx0XCIgaW4gUmVhY3RPcmlnaW5hbCA/IFJlYWN0T3JpZ2luYWxbXCJkZWZhdWx0XCJdIDogUmVhY3RPcmlnaW5hbFxuKTtcblxuLy8gc3JjL2NvbXBvbmVudHMvQ29udGV4dC50c1xudmFyIENvbnRleHRLZXkgPSBTeW1ib2wuZm9yKGByZWFjdC1yZWR1eC1jb250ZXh0YCk7XG52YXIgZ1QgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFRoaXMgOiAoXG4gIC8qIGZhbGwgYmFjayB0byBhIHBlci1tb2R1bGUgc2NvcGUgKHByZS04LjEgYmVoYXZpb3VyKSBpZiBgZ2xvYmFsVGhpc2AgaXMgbm90IGF2YWlsYWJsZSAqL1xuICB7fVxuKTtcbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGlmICghUmVhY3QuY3JlYXRlQ29udGV4dClcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IGNvbnRleHRNYXAgPSBnVFtDb250ZXh0S2V5XSA/PyAoZ1RbQ29udGV4dEtleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgbGV0IHJlYWxDb250ZXh0ID0gY29udGV4dE1hcC5nZXQoUmVhY3QuY3JlYXRlQ29udGV4dCk7XG4gIGlmICghcmVhbENvbnRleHQpIHtcbiAgICByZWFsQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoXG4gICAgICBudWxsXG4gICAgKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWFsQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUmVhY3RSZWR1eFwiO1xuICAgIH1cbiAgICBjb250ZXh0TWFwLnNldChSZWFjdC5jcmVhdGVDb250ZXh0LCByZWFsQ29udGV4dCk7XG4gIH1cbiAgcmV0dXJuIHJlYWxDb250ZXh0O1xufVxudmFyIFJlYWN0UmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGdldENvbnRleHQoKTtcblxuLy8gc3JjL3V0aWxzL3VzZVN5bmNFeHRlcm5hbFN0b3JlLnRzXG52YXIgbm90SW5pdGlhbGl6ZWQgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcInVTRVMgbm90IGluaXRpYWxpemVkIVwiKTtcbn07XG5cbi8vIHNyYy9ob29rcy91c2VSZWR1eENvbnRleHQudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VSZWR1eENvbnRleHQyKCkge1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhY29udGV4dFZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiY291bGQgbm90IGZpbmQgcmVhY3QtcmVkdXggY29udGV4dCB2YWx1ZTsgcGxlYXNlIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHdyYXBwZWQgaW4gYSA8UHJvdmlkZXI+XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gIH07XG59XG52YXIgdXNlUmVkdXhDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVJlZHV4Q29udGV4dEhvb2soKTtcblxuLy8gc3JjL2hvb2tzL3VzZVNlbGVjdG9yLnRzXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBub3RJbml0aWFsaXplZDtcbnZhciBpbml0aWFsaXplVXNlU2VsZWN0b3IgPSAoZm4pID0+IHtcbiAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmbjtcbn07XG52YXIgcmVmRXF1YWxpdHkgPSAoYSwgYikgPT4gYSA9PT0gYjtcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9ySG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogY3JlYXRlUmVkdXhDb250ZXh0SG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlU2VsZWN0b3IyID0gKHNlbGVjdG9yLCBlcXVhbGl0eUZuT3JPcHRpb25zID0ge30pID0+IHtcbiAgICBjb25zdCB7IGVxdWFsaXR5Rm4gPSByZWZFcXVhbGl0eSwgZGV2TW9kZUNoZWNrcyA9IHt9IH0gPSB0eXBlb2YgZXF1YWxpdHlGbk9yT3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8geyBlcXVhbGl0eUZuOiBlcXVhbGl0eUZuT3JPcHRpb25zIH0gOiBlcXVhbGl0eUZuT3JPcHRpb25zO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgc2VsZWN0b3IgdG8gdXNlU2VsZWN0b3JgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yIHRvIHVzZVNlbGVjdG9yYCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGVxdWFsaXR5Rm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyBhbiBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2VTZWxlY3RvcmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZSxcbiAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXG4gICAgfSA9IHVzZVJlZHV4Q29udGV4dDIoKTtcbiAgICBjb25zdCBmaXJzdFJ1biA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgICBjb25zdCB3cmFwcGVkU2VsZWN0b3IgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAgIHtcbiAgICAgICAgW3NlbGVjdG9yLm5hbWVdKHN0YXRlKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpZGVudGl0eUZ1bmN0aW9uQ2hlY2s6IGZpbmFsSWRlbnRpdHlGdW5jdGlvbkNoZWNrLFxuICAgICAgICAgICAgICBzdGFiaWxpdHlDaGVjazogZmluYWxTdGFiaWxpdHlDaGVja1xuICAgICAgICAgICAgfSA9IHtcbiAgICAgICAgICAgICAgc3RhYmlsaXR5Q2hlY2ssXG4gICAgICAgICAgICAgIGlkZW50aXR5RnVuY3Rpb25DaGVjayxcbiAgICAgICAgICAgICAgLi4uZGV2TW9kZUNoZWNrc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChmaW5hbFN0YWJpbGl0eUNoZWNrID09PSBcImFsd2F5c1wiIHx8IGZpbmFsU3RhYmlsaXR5Q2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9Db21wYXJlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm4oc2VsZWN0ZWQsIHRvQ29tcGFyZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhY2sgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICh7IHN0YWNrIH0gPSBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgXCJTZWxlY3RvciBcIiArIChzZWxlY3Rvci5uYW1lIHx8IFwidW5rbm93blwiKSArIFwiIHJldHVybmVkIGEgZGlmZmVyZW50IHJlc3VsdCB3aGVuIGNhbGxlZCB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnMuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiBhIG5ldyByZWZlcmVuY2UgKHN1Y2ggYXMgYW4gb2JqZWN0IG9yIGFuIGFycmF5KSBzaG91bGQgYmUgbWVtb2l6ZWQ6IGh0dHBzOi8vcmVkdXguanMub3JnL3VzYWdlL2Rlcml2aW5nLWRhdGEtc2VsZWN0b3JzI29wdGltaXppbmctc2VsZWN0b3JzLXdpdGgtbWVtb2l6YXRpb25cIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDI6IHRvQ29tcGFyZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwiYWx3YXlzXCIgfHwgZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2sgPT09IFwib25jZVwiICYmIGZpcnN0UnVuLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgKHsgc3RhY2sgfSA9IGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICBcIlNlbGVjdG9yIFwiICsgKHNlbGVjdG9yLm5hbWUgfHwgXCJ1bmtub3duXCIpICsgXCIgcmV0dXJuZWQgdGhlIHJvb3Qgc3RhdGUgd2hlbiBjYWxsZWQuIFRoaXMgY2FuIGxlYWQgdG8gdW5uZWNlc3NhcnkgcmVyZW5kZXJzLlxcblNlbGVjdG9ycyB0aGF0IHJldHVybiB0aGUgZW50aXJlIHN0YXRlIGFyZSBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSwgYXMgdGhleSB3aWxsIGNhdXNlIGEgcmVyZW5kZXIgd2hlbmV2ZXIgKmFueXRoaW5nKiBpbiBzdGF0ZSBjaGFuZ2VzLlwiLFxuICAgICAgICAgICAgICAgICAgeyBzdGFjayB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0UnVuLmN1cnJlbnQpXG4gICAgICAgICAgICAgIGZpcnN0UnVuLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgICB9W3NlbGVjdG9yLm5hbWVdLFxuICAgICAgW3NlbGVjdG9yLCBzdGFiaWxpdHlDaGVjaywgZGV2TW9kZUNoZWNrcy5zdGFiaWxpdHlDaGVja11cbiAgICApO1xuICAgIGNvbnN0IHNlbGVjdGVkU3RhdGUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihcbiAgICAgIHN1YnNjcmlwdGlvbi5hZGROZXN0ZWRTdWIsXG4gICAgICBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgIGdldFNlcnZlclN0YXRlIHx8IHN0b3JlLmdldFN0YXRlLFxuICAgICAgd3JhcHBlZFNlbGVjdG9yLFxuICAgICAgZXF1YWxpdHlGblxuICAgICk7XG4gICAgUmVhY3QudXNlRGVidWdWYWx1ZShzZWxlY3RlZFN0YXRlKTtcbiAgICByZXR1cm4gc2VsZWN0ZWRTdGF0ZTtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTZWxlY3RvcjIsIHtcbiAgICB3aXRoVHlwZXM6ICgpID0+IHVzZVNlbGVjdG9yMlxuICB9KTtcbiAgcmV0dXJuIHVzZVNlbGVjdG9yMjtcbn1cbnZhciB1c2VTZWxlY3RvciA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVTZWxlY3Rvckhvb2soKTtcblxuLy8gc3JjL3V0aWxzL3JlYWN0LWlzLnRzXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIik7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIik7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zZXJ2ZXJfY29udGV4dFwiKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICBjb25zdCAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRToge1xuICAgICAgICBjb25zdCB0eXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0ICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOiB7XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5cbi8vIHNyYy91dGlscy93YXJuaW5nLnRzXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIHRyeSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7XG4gIH1cbn1cblxuLy8gc3JjL2Nvbm5lY3QvdmVyaWZ5U3Vic2VsZWN0b3JzLnRzXG5mdW5jdGlvbiB2ZXJpZnkoc2VsZWN0b3IsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFzZWxlY3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCB2YWx1ZSBmb3IgJHttZXRob2ROYW1lfSBpbiBjb25uZWN0LmApO1xuICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09IFwibWFwU3RhdGVUb1Byb3BzXCIgfHwgbWV0aG9kTmFtZSA9PT0gXCJtYXBEaXNwYXRjaFRvUHJvcHNcIikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCBcImRlcGVuZHNPbk93blByb3BzXCIpKSB7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICBgVGhlIHNlbGVjdG9yIGZvciAke21ldGhvZE5hbWV9IG9mIGNvbm5lY3QgZGlkIG5vdCBzcGVjaWZ5IGEgdmFsdWUgZm9yIGRlcGVuZHNPbk93blByb3BzLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgXCJtYXBTdGF0ZVRvUHJvcHNcIik7XG4gIHZlcmlmeShtYXBEaXNwYXRjaFRvUHJvcHMsIFwibWFwRGlzcGF0Y2hUb1Byb3BzXCIpO1xuICB2ZXJpZnkobWVyZ2VQcm9wcywgXCJtZXJnZVByb3BzXCIpO1xufVxuXG4vLyBzcmMvY29ubmVjdC9zZWxlY3RvckZhY3RvcnkudHNcbmZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBkaXNwYXRjaCwge1xuICBhcmVTdGF0ZXNFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsXG59KSB7XG4gIGxldCBoYXNSdW5BdExlYXN0T25jZSA9IGZhbHNlO1xuICBsZXQgc3RhdGU7XG4gIGxldCBvd25Qcm9wcztcbiAgbGV0IHN0YXRlUHJvcHM7XG4gIGxldCBkaXNwYXRjaFByb3BzO1xuICBsZXQgbWVyZ2VkUHJvcHM7XG4gIGZ1bmN0aW9uIGhhbmRsZUZpcnN0Q2FsbChmaXJzdFN0YXRlLCBmaXJzdE93blByb3BzKSB7XG4gICAgc3RhdGUgPSBmaXJzdFN0YXRlO1xuICAgIG93blByb3BzID0gZmlyc3RPd25Qcm9wcztcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgaGFzUnVuQXRMZWFzdE9uY2UgPSB0cnVlO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCkge1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBpZiAobWFwRGlzcGF0Y2hUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKVxuICAgICAgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1Byb3BzKCkge1xuICAgIGlmIChtYXBTdGF0ZVRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpXG4gICAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcylcbiAgICAgIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVOZXdTdGF0ZSgpIHtcbiAgICBjb25zdCBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlUHJvcHNDaGFuZ2VkID0gIWFyZVN0YXRlUHJvcHNFcXVhbChuZXh0U3RhdGVQcm9wcywgc3RhdGVQcm9wcyk7XG4gICAgc3RhdGVQcm9wcyA9IG5leHRTdGF0ZVByb3BzO1xuICAgIGlmIChzdGF0ZVByb3BzQ2hhbmdlZClcbiAgICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIGNvbnN0IHByb3BzQ2hhbmdlZCA9ICFhcmVPd25Qcm9wc0VxdWFsKG5leHRPd25Qcm9wcywgb3duUHJvcHMpO1xuICAgIGNvbnN0IHN0YXRlQ2hhbmdlZCA9ICFhcmVTdGF0ZXNFcXVhbChcbiAgICAgIG5leHRTdGF0ZSxcbiAgICAgIHN0YXRlLFxuICAgICAgbmV4dE93blByb3BzLFxuICAgICAgb3duUHJvcHNcbiAgICApO1xuICAgIHN0YXRlID0gbmV4dFN0YXRlO1xuICAgIG93blByb3BzID0gbmV4dE93blByb3BzO1xuICAgIGlmIChwcm9wc0NoYW5nZWQgJiYgc3RhdGVDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1Byb3BzQW5kTmV3U3RhdGUoKTtcbiAgICBpZiAocHJvcHNDaGFuZ2VkKVxuICAgICAgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZClcbiAgICAgIHJldHVybiBoYW5kbGVOZXdTdGF0ZSgpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvcihuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykge1xuICAgIHJldHVybiBoYXNSdW5BdExlYXN0T25jZSA/IGhhbmRsZVN1YnNlcXVlbnRDYWxscyhuZXh0U3RhdGUsIG5leHRPd25Qcm9wcykgOiBoYW5kbGVGaXJzdENhbGwobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpO1xuICB9O1xufVxuZnVuY3Rpb24gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShkaXNwYXRjaCwge1xuICBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICBpbml0TWVyZ2VQcm9wcyxcbiAgLi4ub3B0aW9uc1xufSkge1xuICBjb25zdCBtYXBTdGF0ZVRvUHJvcHMgPSBpbml0TWFwU3RhdGVUb1Byb3BzKGRpc3BhdGNoLCBvcHRpb25zKTtcbiAgY29uc3QgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGNvbnN0IG1lcmdlUHJvcHMgPSBpbml0TWVyZ2VQcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2ZXJpZnlTdWJzZWxlY3RvcnMobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMpO1xuICB9XG4gIHJldHVybiBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGF0Y2gsIG9wdGlvbnMpO1xufVxuXG4vLyBzcmMvdXRpbHMvYmluZEFjdGlvbkNyZWF0b3JzLnRzXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcnMoYWN0aW9uQ3JlYXRvcnMsIGRpc3BhdGNoKSB7XG4gIGNvbnN0IGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYWN0aW9uQ3JlYXRvcnMpIHtcbiAgICBjb25zdCBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gKC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IoLi4uYXJncykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuLy8gc3JjL3V0aWxzL2lzUGxhaW5PYmplY3QudHNcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGlmIChwcm90byA9PT0gbnVsbClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgbGV0IGJhc2VQcm90byA9IHByb3RvO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcbiAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcbiAgfVxuICByZXR1cm4gcHJvdG8gPT09IGJhc2VQcm90bztcbn1cblxuLy8gc3JjL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LnRzXG5mdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm5pbmcoXG4gICAgICBgJHttZXRob2ROYW1lfSgpIGluICR7ZGlzcGxheU5hbWV9IG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7dmFsdWV9LmBcbiAgICApO1xuICB9XG59XG5cbi8vIHNyYy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLnRzXG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGdldENvbnN0YW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0Q29uc3RhbnRTZWxlY3RvcihkaXNwYXRjaCkge1xuICAgIGNvbnN0IGNvbnN0YW50ID0gZ2V0Q29uc3RhbnQoZGlzcGF0Y2gpO1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50U2VsZWN0b3IoKSB7XG4gICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgfVxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgPyBCb29sZWFuKG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIDogbWFwVG9Qcm9wcy5sZW5ndGggIT09IDE7XG59XG5mdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIHsgZGlzcGxheU5hbWUgfSkge1xuICAgIGNvbnN0IHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCwgdm9pZCAwKTtcbiAgICB9O1xuICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gdHJ1ZTtcbiAgICBwcm94eS5tYXBUb1Byb3BzID0gZnVuY3Rpb24gZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKSB7XG4gICAgICBwcm94eS5tYXBUb1Byb3BzID0gbWFwVG9Qcm9wcztcbiAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMobWFwVG9Qcm9wcyk7XG4gICAgICBsZXQgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwcm94eS5tYXBUb1Byb3BzID0gcHJvcHM7XG4gICAgICAgIHByb3h5LmRlcGVuZHNPbk93blByb3BzID0gZ2V0RGVwZW5kc09uT3duUHJvcHMocHJvcHMpO1xuICAgICAgICBwcm9wcyA9IHByb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgdmVyaWZ5UGxhaW5PYmplY3QocHJvcHMsIGRpc3BsYXlOYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHJldHVybiBwcm9wcztcbiAgICB9O1xuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvaW52YWxpZEFyZ0ZhY3RvcnkudHNcbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KGFyZywgbmFtZSkge1xuICByZXR1cm4gKGRpc3BhdGNoLCBvcHRpb25zKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhcmd9IGZvciAke25hbWV9IGFyZ3VtZW50IHdoZW4gY29ubmVjdGluZyBjb21wb25lbnQgJHtvcHRpb25zLndyYXBwZWRDb21wb25lbnROYW1lfS5gXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLnRzXG5mdW5jdGlvbiBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwib2JqZWN0XCIgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KFxuICAgIChkaXNwYXRjaCkgPT4gKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpXG4gICAgKVxuICApIDogIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoKGRpc3BhdGNoKSA9PiAoe1xuICAgIGRpc3BhdGNoXG4gIH0pKSA6IHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIilcbiAgKSA6IGNyZWF0ZUludmFsaWRBcmdGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcywgXCJtYXBEaXNwYXRjaFRvUHJvcHNcIik7XG59XG5cbi8vIHNyYy9jb25uZWN0L21hcFN0YXRlVG9Qcm9wcy50c1xuZnVuY3Rpb24gbWFwU3RhdGVUb1Byb3BzRmFjdG9yeShtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KCgpID0+ICh7fSkpIDogdHlwZW9mIG1hcFN0YXRlVG9Qcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKVxuICApIDogY3JlYXRlSW52YWxpZEFyZ0ZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBcIm1hcFN0YXRlVG9Qcm9wc1wiKTtcbn1cblxuLy8gc3JjL2Nvbm5lY3QvbWVyZ2VQcm9wcy50c1xuZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIHsgLi4ub3duUHJvcHMsIC4uLnN0YXRlUHJvcHMsIC4uLmRpc3BhdGNoUHJvcHMgfTtcbn1cbmZ1bmN0aW9uIHdyYXBNZXJnZVByb3BzRnVuYyhtZXJnZVByb3BzKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbml0TWVyZ2VQcm9wc1Byb3h5KGRpc3BhdGNoLCB7IGRpc3BsYXlOYW1lLCBhcmVNZXJnZWRQcm9wc0VxdWFsIH0pIHtcbiAgICBsZXQgaGFzUnVuT25jZSA9IGZhbHNlO1xuICAgIGxldCBtZXJnZWRQcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VQcm9wc1Byb3h5KHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gICAgICBjb25zdCBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICAgIGlmIChoYXNSdW5PbmNlKSB7XG4gICAgICAgIGlmICghYXJlTWVyZ2VkUHJvcHNFcXVhbChuZXh0TWVyZ2VkUHJvcHMsIG1lcmdlZFByb3BzKSlcbiAgICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgICB2ZXJpZnlQbGFpbk9iamVjdChtZXJnZWRQcm9wcywgZGlzcGxheU5hbWUsIFwibWVyZ2VQcm9wc1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcykge1xuICByZXR1cm4gIW1lcmdlUHJvcHMgPyAoKSA9PiBkZWZhdWx0TWVyZ2VQcm9wcyA6IHR5cGVvZiBtZXJnZVByb3BzID09PSBcImZ1bmN0aW9uXCIgPyB3cmFwTWVyZ2VQcm9wc0Z1bmMobWVyZ2VQcm9wcykgOiBjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeShtZXJnZVByb3BzLCBcIm1lcmdlUHJvcHNcIik7XG59XG5cbi8vIHNyYy91dGlscy9iYXRjaC50c1xuZnVuY3Rpb24gZGVmYXVsdE5vb3BCYXRjaChjYWxsYmFjaykge1xuICBjYWxsYmFjaygpO1xufVxuXG4vLyBzcmMvdXRpbHMvU3Vic2NyaXB0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIGxldCBmaXJzdCA9IG51bGw7XG4gIGxldCBsYXN0ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcigpIHtcbiAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICAgIGxhc3QgPSBudWxsO1xuICAgIH0sXG4gICAgbm90aWZ5KCkge1xuICAgICAgZGVmYXVsdE5vb3BCYXRjaCgoKSA9PiB7XG4gICAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjaygpO1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgIGxldCBsaXN0ZW5lciA9IGZpcnN0O1xuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICB9LFxuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgbGV0IGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IGxhc3QgPSB7XG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0XG4gICAgICB9O1xuICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgbGlzdGVuZXIucHJldi5uZXh0ID0gbGlzdGVuZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdCA9IGxpc3RlbmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLm5leHQucHJldiA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5KCkge1xuICB9LFxuICBnZXQ6ICgpID0+IFtdXG59O1xuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlLCBwYXJlbnRTdWIpIHtcbiAgbGV0IHVuc3Vic2NyaWJlO1xuICBsZXQgbGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgbGV0IHN1YnNjcmlwdGlvbnNBbW91bnQgPSAwO1xuICBsZXQgc2VsZlN1YnNjcmliZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdHJ5U3Vic2NyaWJlKCk7XG4gICAgY29uc3QgY2xlYW51cExpc3RlbmVyID0gbGlzdGVuZXJzLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKCFyZW1vdmVkKSB7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXIoKTtcbiAgICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgbGlzdGVuZXJzLm5vdGlmeSgpO1xuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVdyYXBwZXIoKSB7XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlKSB7XG4gICAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIHNlbGZTdWJzY3JpYmVkO1xuICB9XG4gIGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBzdWJzY3JpcHRpb25zQW1vdW50Kys7XG4gICAgaWYgKCF1bnN1YnNjcmliZSkge1xuICAgICAgdW5zdWJzY3JpYmUgPSBwYXJlbnRTdWIgPyBwYXJlbnRTdWIuYWRkTmVzdGVkU3ViKGhhbmRsZUNoYW5nZVdyYXBwZXIpIDogc3RvcmUuc3Vic2NyaWJlKGhhbmRsZUNoYW5nZVdyYXBwZXIpO1xuICAgICAgbGlzdGVuZXJzID0gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIHN1YnNjcmlwdGlvbnNBbW91bnQtLTtcbiAgICBpZiAodW5zdWJzY3JpYmUgJiYgc3Vic2NyaXB0aW9uc0Ftb3VudCA9PT0gMCkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIHVuc3Vic2NyaWJlID0gdm9pZCAwO1xuICAgICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICBsaXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlTdWJzY3JpYmVTZWxmKCkge1xuICAgIGlmICghc2VsZlN1YnNjcmliZWQpIHtcbiAgICAgIHNlbGZTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgIHRyeVN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZVNlbGYoKSB7XG4gICAgaWYgKHNlbGZTdWJzY3JpYmVkKSB7XG4gICAgICBzZWxmU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgdHJ5VW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3Vic2NyaXB0aW9uID0ge1xuICAgIGFkZE5lc3RlZFN1YixcbiAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgIGhhbmRsZUNoYW5nZVdyYXBwZXIsXG4gICAgaXNTdWJzY3JpYmVkLFxuICAgIHRyeVN1YnNjcmliZTogdHJ5U3Vic2NyaWJlU2VsZixcbiAgICB0cnlVbnN1YnNjcmliZTogdHJ5VW5zdWJzY3JpYmVTZWxmLFxuICAgIGdldExpc3RlbmVyczogKCkgPT4gbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBzdWJzY3JpcHRpb247XG59XG5cbi8vIHNyYy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LnRzXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIik7XG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGNhblVzZURPTSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcblxuLy8gc3JjL3V0aWxzL3NoYWxsb3dFcXVhbC50c1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09IFwib2JqZWN0XCIgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvdXRpbHMvaG9pc3RTdGF0aWNzLnRzXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxuICBjb250ZXh0VHlwZXM6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIG1peGluczogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcbnZhciBGT1JXQVJEX1JFRl9TVEFUSUNTID0ge1xuICAkJHR5cGVvZjogdHJ1ZSxcbiAgcmVuZGVyOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWVcbn07XG52YXIgTUVNT19TVEFUSUNTID0ge1xuICAkJHR5cGVvZjogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIFRZUEVfU1RBVElDUyA9IHtcbiAgW0ZvcndhcmRSZWZdOiBGT1JXQVJEX1JFRl9TVEFUSUNTLFxuICBbTWVtb106IE1FTU9fU1RBVElDU1xufTtcbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XG4gIGlmIChpc01lbW8oY29tcG9uZW50KSkge1xuICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gIH1cbiAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbXCIkJHR5cGVvZlwiXV0gfHwgUkVBQ1RfU1RBVElDUztcbn1cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIGNvbnN0IGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcbiAgICBjb25zdCBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleV0pKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL2Nvbm5lY3QudHN4XG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBub3RJbml0aWFsaXplZDtcbnZhciBpbml0aWFsaXplQ29ubmVjdCA9IChmbikgPT4ge1xuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGZuO1xufTtcbnZhciBOT19TVUJTQ1JJUFRJT05fQVJSQVkgPSBbbnVsbCwgbnVsbF07XG52YXIgc3RyaW5naWZ5Q29tcG9uZW50ID0gKENvbXApID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoQ29tcCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcoQ29tcCk7XG4gIH1cbn07XG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoZWZmZWN0RnVuYywgZWZmZWN0QXJncywgZGVwZW5kZW5jaWVzKSB7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gZWZmZWN0RnVuYyguLi5lZmZlY3RBcmdzKSwgZGVwZW5kZW5jaWVzKTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVXcmFwcGVyUHJvcHMobGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCB3cmFwcGVyUHJvcHMsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMpIHtcbiAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50ID0gd3JhcHBlclByb3BzO1xuICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gZmFsc2U7XG4gIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQpIHtcbiAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBudWxsO1xuICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgfVxufVxuZnVuY3Rpb24gc3Vic2NyaWJlVXBkYXRlcyhzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsIHN0b3JlLCBzdWJzY3JpcHRpb24sIGNoaWxkUHJvcHNTZWxlY3RvciwgbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCBpc01vdW50ZWQsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMsIGFkZGl0aW9uYWxTdWJzY3JpYmVMaXN0ZW5lcikge1xuICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcylcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgIH07XG4gIGxldCBkaWRVbnN1YnNjcmliZSA9IGZhbHNlO1xuICBsZXQgbGFzdFRocm93bkVycm9yID0gbnVsbDtcbiAgY29uc3QgY2hlY2tGb3JVcGRhdGVzID0gKCkgPT4ge1xuICAgIGlmIChkaWRVbnN1YnNjcmliZSB8fCAhaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF0ZXN0U3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgbGV0IG5ld0NoaWxkUHJvcHMsIGVycm9yO1xuICAgIHRyeSB7XG4gICAgICBuZXdDaGlsZFByb3BzID0gY2hpbGRQcm9wc1NlbGVjdG9yKFxuICAgICAgICBsYXRlc3RTdG9yZVN0YXRlLFxuICAgICAgICBsYXN0V3JhcHBlclByb3BzLmN1cnJlbnRcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IgPSBlO1xuICAgICAgbGFzdFRocm93bkVycm9yID0gZTtcbiAgICB9XG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgbGFzdFRocm93bkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG5ld0NoaWxkUHJvcHMgPT09IGxhc3RDaGlsZFByb3BzLmN1cnJlbnQpIHtcbiAgICAgIGlmICghcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCkge1xuICAgICAgICBub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgYWRkaXRpb25hbFN1YnNjcmliZUxpc3RlbmVyKCk7XG4gICAgfVxuICB9O1xuICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IGNoZWNrRm9yVXBkYXRlcztcbiAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICBjaGVja0ZvclVwZGF0ZXMoKTtcbiAgY29uc3QgdW5zdWJzY3JpYmVXcmFwcGVyID0gKCkgPT4ge1xuICAgIGRpZFVuc3Vic2NyaWJlID0gdHJ1ZTtcbiAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IG51bGw7XG4gICAgaWYgKGxhc3RUaHJvd25FcnJvcikge1xuICAgICAgdGhyb3cgbGFzdFRocm93bkVycm9yO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVuc3Vic2NyaWJlV3JhcHBlcjtcbn1cbmZ1bmN0aW9uIHN0cmljdEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkUHVyZU9wdGlvbiA9IGZhbHNlO1xuZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywge1xuICAvLyBUaGUgYHB1cmVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkLCBzbyBUUyBkb2Vzbid0IGxpa2UgdXMgZGVzdHJ1Y3R1cmluZyB0aGlzIHRvIGNoZWNrIGl0cyBleGlzdGVuY2UuXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHVyZSxcbiAgYXJlU3RhdGVzRXF1YWwgPSBzdHJpY3RFcXVhbCxcbiAgYXJlT3duUHJvcHNFcXVhbCA9IHNoYWxsb3dFcXVhbCxcbiAgYXJlU3RhdGVQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gc2hhbGxvd0VxdWFsLFxuICAvLyB1c2UgUmVhY3QncyBmb3J3YXJkUmVmIHRvIGV4cG9zZSBhIHJlZiBvZiB0aGUgd3JhcHBlZCBjb21wb25lbnRcbiAgZm9yd2FyZFJlZiA9IGZhbHNlLFxuICAvLyB0aGUgY29udGV4dCBjb25zdW1lciB0byB1c2VcbiAgY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0XG59ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmIChwdXJlICE9PSB2b2lkIDAgJiYgIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24pIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZFB1cmVPcHRpb24gPSB0cnVlO1xuICAgICAgd2FybmluZyhcbiAgICAgICAgJ1RoZSBgcHVyZWAgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWQuIGBjb25uZWN0YCBpcyBub3cgYWx3YXlzIGEgXCJwdXJlL21lbW9pemVkXCIgY29tcG9uZW50J1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgQ29udGV4dCA9IGNvbnRleHQ7XG4gIGNvbnN0IGluaXRNYXBTdGF0ZVRvUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHNGYWN0b3J5KG1hcFN0YXRlVG9Qcm9wcyk7XG4gIGNvbnN0IGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3J5KG1hcERpc3BhdGNoVG9Qcm9wcyk7XG4gIGNvbnN0IGluaXRNZXJnZVByb3BzID0gbWVyZ2VQcm9wc0ZhY3RvcnkobWVyZ2VQcm9wcyk7XG4gIGNvbnN0IHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcyA9IEJvb2xlYW4obWFwU3RhdGVUb1Byb3BzKTtcbiAgY29uc3Qgd3JhcFdpdGhDb25uZWN0ID0gKFdyYXBwZWRDb21wb25lbnQpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zdCBpc1ZhbGlkID0gLyogQF9fUFVSRV9fICovIGlzVmFsaWRFbGVtZW50VHlwZShXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgY29tcG9uZW50IHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBjb25uZWN0LiBJbnN0ZWFkIHJlY2VpdmVkICR7c3RyaW5naWZ5Q29tcG9uZW50KFxuICAgICAgICAgICAgV3JhcHBlZENvbXBvbmVudFxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgIH1cbiAgICBjb25zdCB3cmFwcGVkQ29tcG9uZW50TmFtZSA9IFdyYXBwZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgV3JhcHBlZENvbXBvbmVudC5uYW1lIHx8IFwiQ29tcG9uZW50XCI7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBgQ29ubmVjdCgke3dyYXBwZWRDb21wb25lbnROYW1lfSlgO1xuICAgIGNvbnN0IHNlbGVjdG9yRmFjdG9yeU9wdGlvbnMgPSB7XG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBkaXNwbGF5TmFtZSxcbiAgICAgIHdyYXBwZWRDb21wb25lbnROYW1lLFxuICAgICAgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMsXG4gICAgICBhcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsXG4gICAgfTtcbiAgICBmdW5jdGlvbiBDb25uZWN0RnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIGNvbnN0IFtwcm9wc0NvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc10gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmMiwgLi4ud3JhcHBlclByb3BzMiB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiBbcHJvcHMuY29udGV4dCwgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjIsIHdyYXBwZXJQcm9wczJdO1xuICAgICAgfSwgW3Byb3BzXSk7XG4gICAgICBjb25zdCBDb250ZXh0VG9Vc2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgbGV0IFJlc3VsdENvbnRleHQgPSBDb250ZXh0O1xuICAgICAgICBpZiAocHJvcHNDb250ZXh0Py5Db25zdW1lcikge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSAvKiBAX19QVVJFX18gKi8gaXNDb250ZXh0Q29uc3VtZXIoXG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQocHJvcHNDb250ZXh0LkNvbnN1bWVyLCBudWxsKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3QgY29udGV4dCBjb25zdW1lciBhcyBgcHJvcHMuY29udGV4dGBcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVzdWx0Q29udGV4dCA9IHByb3BzQ29udGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlc3VsdENvbnRleHQ7XG4gICAgICB9LCBbcHJvcHNDb250ZXh0LCBDb250ZXh0XSk7XG4gICAgICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KENvbnRleHRUb1VzZSk7XG4gICAgICBjb25zdCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPSBCb29sZWFuKHByb3BzLnN0b3JlKSAmJiBCb29sZWFuKHByb3BzLnN0b3JlLmdldFN0YXRlKSAmJiBCb29sZWFuKHByb3BzLnN0b3JlLmRpc3BhdGNoKTtcbiAgICAgIGNvbnN0IGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID0gQm9vbGVhbihjb250ZXh0VmFsdWUpICYmIEJvb2xlYW4oY29udGV4dFZhbHVlLnN0b3JlKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWRpZFN0b3JlQ29tZUZyb21Qcm9wcyAmJiAhZGlkU3RvcmVDb21lRnJvbUNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDb3VsZCBub3QgZmluZCBcInN0b3JlXCIgaW4gdGhlIGNvbnRleHQgb2YgXCIke2Rpc3BsYXlOYW1lfVwiLiBFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCBvciBwYXNzIGEgY3VzdG9tIFJlYWN0IGNvbnRleHQgcHJvdmlkZXIgdG8gPFByb3ZpZGVyPiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgUmVhY3QgY29udGV4dCBjb25zdW1lciB0byAke2Rpc3BsYXlOYW1lfSBpbiBjb25uZWN0IG9wdGlvbnMuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmUgPSBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyBwcm9wcy5zdG9yZSA6IGNvbnRleHRWYWx1ZS5zdG9yZTtcbiAgICAgIGNvbnN0IGdldFNlcnZlclN0YXRlID0gZGlkU3RvcmVDb21lRnJvbUNvbnRleHQgPyBjb250ZXh0VmFsdWUuZ2V0U2VydmVyU3RhdGUgOiBzdG9yZS5nZXRTdGF0ZTtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNTZWxlY3RvciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gZmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeShzdG9yZS5kaXNwYXRjaCwgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyk7XG4gICAgICB9LCBbc3RvcmVdKTtcbiAgICAgIGNvbnN0IFtzdWJzY3JpcHRpb24sIG5vdGlmeU5lc3RlZFN1YnNdID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKVxuICAgICAgICAgIHJldHVybiBOT19TVUJTQ1JJUFRJT05fQVJSQVk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbjIgPSBjcmVhdGVTdWJzY3JpcHRpb24oXG4gICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgZGlkU3RvcmVDb21lRnJvbVByb3BzID8gdm9pZCAwIDogY29udGV4dFZhbHVlLnN1YnNjcmlwdGlvblxuICAgICAgICApO1xuICAgICAgICBjb25zdCBub3RpZnlOZXN0ZWRTdWJzMiA9IHN1YnNjcmlwdGlvbjIubm90aWZ5TmVzdGVkU3Vicy5iaW5kKHN1YnNjcmlwdGlvbjIpO1xuICAgICAgICByZXR1cm4gW3N1YnNjcmlwdGlvbjIsIG5vdGlmeU5lc3RlZFN1YnMyXTtcbiAgICAgIH0sIFtzdG9yZSwgZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWVdKTtcbiAgICAgIGNvbnN0IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGRpZFN0b3JlQ29tZUZyb21Qcm9wcykge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5jb250ZXh0VmFsdWUsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICB9LCBbZGlkU3RvcmVDb21lRnJvbVByb3BzLCBjb250ZXh0VmFsdWUsIHN1YnNjcmlwdGlvbl0pO1xuICAgICAgY29uc3QgbGFzdENoaWxkUHJvcHMgPSBSZWFjdC51c2VSZWYoKTtcbiAgICAgIGNvbnN0IGxhc3RXcmFwcGVyUHJvcHMgPSBSZWFjdC51c2VSZWYod3JhcHBlclByb3BzKTtcbiAgICAgIGNvbnN0IGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUgPSBSZWFjdC51c2VSZWYoKTtcbiAgICAgIGNvbnN0IHJlbmRlcklzU2NoZWR1bGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlzUHJvY2Vzc2luZ0Rpc3BhdGNoID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgICAgIGNvbnN0IGlzTW91bnRlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgICBjb25zdCBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yID0gUmVhY3QudXNlUmVmKCk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9LCBbXSk7XG4gICAgICBjb25zdCBhY3R1YWxDaGlsZFByb3BzU2VsZWN0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCAmJiB3cmFwcGVyUHJvcHMgPT09IGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNTZWxlY3RvcihzdG9yZS5nZXRTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2VsZWN0b3I7XG4gICAgICB9LCBbc3RvcmUsIHdyYXBwZXJQcm9wc10pO1xuICAgICAgY29uc3Qgc3Vic2NyaWJlRm9yUmVhY3QgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlID0gKHJlYWN0TGlzdGVuZXIpID0+IHtcbiAgICAgICAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVVcGRhdGVzKFxuICAgICAgICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLFxuICAgICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjaGlsZFByb3BzU2VsZWN0b3IsXG4gICAgICAgICAgICBsYXN0V3JhcHBlclByb3BzLFxuICAgICAgICAgICAgbGFzdENoaWxkUHJvcHMsXG4gICAgICAgICAgICByZW5kZXJJc1NjaGVkdWxlZCxcbiAgICAgICAgICAgIGlzTW91bnRlZCxcbiAgICAgICAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsXG4gICAgICAgICAgICBub3RpZnlOZXN0ZWRTdWJzLFxuICAgICAgICAgICAgcmVhY3RMaXN0ZW5lclxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmU7XG4gICAgICB9LCBbc3Vic2NyaXB0aW9uXSk7XG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoY2FwdHVyZVdyYXBwZXJQcm9wcywgW1xuICAgICAgICBsYXN0V3JhcHBlclByb3BzLFxuICAgICAgICBsYXN0Q2hpbGRQcm9wcyxcbiAgICAgICAgcmVuZGVySXNTY2hlZHVsZWQsXG4gICAgICAgIHdyYXBwZXJQcm9wcyxcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSxcbiAgICAgICAgbm90aWZ5TmVzdGVkU3Vic1xuICAgICAgXSk7XG4gICAgICBsZXQgYWN0dWFsQ2hpbGRQcm9wcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdHVhbENoaWxkUHJvcHMgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICAgICAgICAvLyBUT0RPIFdlJ3JlIHBhc3NpbmcgdGhyb3VnaCBhIGJpZyB3cmFwcGVyIHRoYXQgZG9lcyBhIGJ1bmNoIG9mIGV4dHJhIHNpZGUgZWZmZWN0cyBiZXNpZGVzIHN1YnNjcmliaW5nXG4gICAgICAgICAgc3Vic2NyaWJlRm9yUmVhY3QsXG4gICAgICAgICAgLy8gVE9ETyBUaGlzIGlzIGluY3JlZGlibHkgaGFja3kuIFdlJ3ZlIGFscmVhZHkgcHJvY2Vzc2VkIHRoZSBzdG9yZSB1cGRhdGUgYW5kIGNhbGN1bGF0ZWQgbmV3IGNoaWxkIHByb3BzLFxuICAgICAgICAgIC8vIFRPRE8gYW5kIHdlJ3JlIGp1c3QgcGFzc2luZyB0aGF0IHRocm91Z2ggc28gaXQgdHJpZ2dlcnMgYSByZS1yZW5kZXIgZm9yIHVzIHJhdGhlciB0aGFuIHJlbHlpbmcgb24gYHVTRVNgLlxuICAgICAgICAgIGFjdHVhbENoaWxkUHJvcHNTZWxlY3RvcixcbiAgICAgICAgICBnZXRTZXJ2ZXJTdGF0ZSA/ICgpID0+IGNoaWxkUHJvcHNTZWxlY3RvcihnZXRTZXJ2ZXJTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpIDogYWN0dWFsQ2hpbGRQcm9wc1NlbGVjdG9yXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCkge1xuICAgICAgICAgIDtcbiAgICAgICAgICBlcnIubWVzc2FnZSArPSBgXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxuJHtsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2t9XG5cbmA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gYWN0dWFsQ2hpbGRQcm9wcztcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgV3JhcHBlZENvbXBvbmVudCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uYWN0dWFsQ2hpbGRQcm9wcyxcbiAgICAgICAgICAgICAgcmVmOiByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfSwgW3JlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIFdyYXBwZWRDb21wb25lbnQsIGFjdHVhbENoaWxkUHJvcHNdKTtcbiAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykge1xuICAgICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0VG9Vc2UuUHJvdmlkZXIsIHsgdmFsdWU6IG92ZXJyaWRkZW5Db250ZXh0VmFsdWUgfSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50O1xuICAgICAgfSwgW0NvbnRleHRUb1VzZSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50LCBvdmVycmlkZGVuQ29udGV4dFZhbHVlXSk7XG4gICAgICByZXR1cm4gcmVuZGVyZWRDaGlsZDtcbiAgICB9XG4gICAgY29uc3QgX0Nvbm5lY3QgPSBSZWFjdC5tZW1vKENvbm5lY3RGdW5jdGlvbik7XG4gICAgY29uc3QgQ29ubmVjdCA9IF9Db25uZWN0O1xuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IENvbm5lY3RGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICBjb25zdCBfZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihwcm9wcywgcmVmKSB7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0LCB7IC4uLnByb3BzLCByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWYgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZvcndhcmRlZCA9IF9mb3J3YXJkZWQ7XG4gICAgICBmb3J3YXJkZWQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgIGZvcndhcmRlZC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaG9pc3ROb25SZWFjdFN0YXRpY3MoZm9yd2FyZGVkLCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBob2lzdE5vblJlYWN0U3RhdGljcyhDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbiAgcmV0dXJuIHdyYXBXaXRoQ29ubmVjdDtcbn1cbnZhciBjb25uZWN0X2RlZmF1bHQgPSBjb25uZWN0O1xuXG4vLyBzcmMvY29tcG9uZW50cy9Qcm92aWRlci50c3hcbmZ1bmN0aW9uIFByb3ZpZGVyKHtcbiAgc3RvcmUsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICBzZXJ2ZXJTdGF0ZSxcbiAgc3RhYmlsaXR5Q2hlY2sgPSBcIm9uY2VcIixcbiAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrID0gXCJvbmNlXCJcbn0pIHtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gY3JlYXRlU3Vic2NyaXB0aW9uKHN0b3JlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcmUsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBnZXRTZXJ2ZXJTdGF0ZTogc2VydmVyU3RhdGUgPyAoKSA9PiBzZXJ2ZXJTdGF0ZSA6IHZvaWQgMCxcbiAgICAgIHN0YWJpbGl0eUNoZWNrLFxuICAgICAgaWRlbnRpdHlGdW5jdGlvbkNoZWNrXG4gICAgfTtcbiAgfSwgW3N0b3JlLCBzZXJ2ZXJTdGF0ZSwgc3RhYmlsaXR5Q2hlY2ssIGlkZW50aXR5RnVuY3Rpb25DaGVja10pO1xuICBjb25zdCBwcmV2aW91c1N0YXRlID0gUmVhY3QudXNlTWVtbygoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLCBbc3RvcmVdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgeyBzdWJzY3JpcHRpb24gfSA9IGNvbnRleHRWYWx1ZTtcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzO1xuICAgIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgICBpZiAocHJldmlvdXNTdGF0ZSAhPT0gc3RvcmUuZ2V0U3RhdGUoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSB2b2lkIDA7XG4gICAgfTtcbiAgfSwgW2NvbnRleHRWYWx1ZSwgcHJldmlvdXNTdGF0ZV0pO1xuICBjb25zdCBDb250ZXh0ID0gY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRWYWx1ZSB9LCBjaGlsZHJlbik7XG59XG52YXIgUHJvdmlkZXJfZGVmYXVsdCA9IFByb3ZpZGVyO1xuXG4vLyBzcmMvaG9va3MvdXNlU3RvcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlUmVkdXhDb250ZXh0MiA9IGNvbnRleHQgPT09IFJlYWN0UmVkdXhDb250ZXh0ID8gdXNlUmVkdXhDb250ZXh0IDogKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjcmVhdGVSZWR1eENvbnRleHRIb29rKGNvbnRleHQpXG4gICk7XG4gIGNvbnN0IHVzZVN0b3JlMiA9ICgpID0+IHtcbiAgICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQyKCk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZVN0b3JlMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlU3RvcmUyXG4gIH0pO1xuICByZXR1cm4gdXNlU3RvcmUyO1xufVxudmFyIHVzZVN0b3JlID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVN0b3JlSG9vaygpO1xuXG4vLyBzcmMvaG9va3MvdXNlRGlzcGF0Y2gudHNcbmZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoSG9vayhjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQpIHtcbiAgY29uc3QgdXNlU3RvcmUyID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VTdG9yZSA6IGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0KTtcbiAgY29uc3QgdXNlRGlzcGF0Y2gyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUyKCk7XG4gICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoO1xuICB9O1xuICBPYmplY3QuYXNzaWduKHVzZURpc3BhdGNoMiwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gdXNlRGlzcGF0Y2gyXG4gIH0pO1xuICByZXR1cm4gdXNlRGlzcGF0Y2gyO1xufVxudmFyIHVzZURpc3BhdGNoID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZURpc3BhdGNoSG9vaygpO1xuXG4vLyBzcmMvZXhwb3J0cy50c1xudmFyIGJhdGNoID0gZGVmYXVsdE5vb3BCYXRjaDtcblxuLy8gc3JjL2luZGV4LnRzXG5pbml0aWFsaXplVXNlU2VsZWN0b3IodXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyKTtcbmluaXRpYWxpemVDb25uZWN0KFJlYWN0Mi51c2VTeW5jRXh0ZXJuYWxTdG9yZSk7XG5leHBvcnQge1xuICBQcm92aWRlcl9kZWZhdWx0IGFzIFByb3ZpZGVyLFxuICBSZWFjdFJlZHV4Q29udGV4dCxcbiAgYmF0Y2gsXG4gIGNvbm5lY3RfZGVmYXVsdCBhcyBjb25uZWN0LFxuICBjcmVhdGVEaXNwYXRjaEhvb2ssXG4gIGNyZWF0ZVNlbGVjdG9ySG9vayxcbiAgY3JlYXRlU3RvcmVIb29rLFxuICBzaGFsbG93RXF1YWwsXG4gIHVzZURpc3BhdGNoLFxuICB1c2VTZWxlY3RvcixcbiAgdXNlU3RvcmVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1yZWR1eC5tanMubWFwIl0sIm5hbWVzIjpbIlJlYWN0MiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IyIiwiUmVhY3RPcmlnaW5hbCIsIlJlYWN0IiwiQ29udGV4dEtleSIsIlN5bWJvbCIsImZvciIsImdUIiwiZ2xvYmFsVGhpcyIsImdldENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiY29udGV4dE1hcCIsIk1hcCIsInJlYWxDb250ZXh0IiwiZ2V0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIiwic2V0IiwiUmVhY3RSZWR1eENvbnRleHQiLCJub3RJbml0aWFsaXplZCIsIkVycm9yIiwiY3JlYXRlUmVkdXhDb250ZXh0SG9vayIsImNvbnRleHQiLCJ1c2VSZWR1eENvbnRleHQyIiwiY29udGV4dFZhbHVlIiwidXNlQ29udGV4dCIsInVzZVJlZHV4Q29udGV4dCIsImluaXRpYWxpemVVc2VTZWxlY3RvciIsImZuIiwicmVmRXF1YWxpdHkiLCJhIiwiYiIsImNyZWF0ZVNlbGVjdG9ySG9vayIsInVzZVNlbGVjdG9yMiIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbk9yT3B0aW9ucyIsImVxdWFsaXR5Rm4iLCJkZXZNb2RlQ2hlY2tzIiwic3RvcmUiLCJzdWJzY3JpcHRpb24iLCJnZXRTZXJ2ZXJTdGF0ZSIsInN0YWJpbGl0eUNoZWNrIiwiaWRlbnRpdHlGdW5jdGlvbkNoZWNrIiwiZmlyc3RSdW4iLCJ1c2VSZWYiLCJ3cmFwcGVkU2VsZWN0b3IiLCJ1c2VDYWxsYmFjayIsIm5hbWUiLCJzdGF0ZSIsInNlbGVjdGVkIiwiZmluYWxJZGVudGl0eUZ1bmN0aW9uQ2hlY2siLCJmaW5hbFN0YWJpbGl0eUNoZWNrIiwiY3VycmVudCIsInRvQ29tcGFyZSIsInN0YWNrIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwic2VsZWN0ZWQyIiwic2VsZWN0ZWRTdGF0ZSIsImFkZE5lc3RlZFN1YiIsImdldFN0YXRlIiwidXNlRGVidWdWYWx1ZSIsIk9iamVjdCIsImFzc2lnbiIsIndpdGhUeXBlcyIsInVzZVNlbGVjdG9yIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiUkVBQ1RfT0ZGU0NSRUVOX1RZUEUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiRm9yd2FyZFJlZiIsIk1lbW8iLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInR5cGVPZiIsIm9iamVjdCIsIiQkdHlwZW9mVHlwZSIsImlzQ29udGV4dENvbnN1bWVyIiwiaXNNZW1vIiwid2FybmluZyIsIm1lc3NhZ2UiLCJlcnJvciIsInZlcmlmeSIsIm1ldGhvZE5hbWUiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2ZXJpZnlTdWJzZWxlY3RvcnMiLCJtYXBTdGF0ZVRvUHJvcHMiLCJtYXBEaXNwYXRjaFRvUHJvcHMiLCJtZXJnZVByb3BzIiwicHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkiLCJkaXNwYXRjaCIsImFyZVN0YXRlc0VxdWFsIiwiYXJlT3duUHJvcHNFcXVhbCIsImFyZVN0YXRlUHJvcHNFcXVhbCIsImhhc1J1bkF0TGVhc3RPbmNlIiwib3duUHJvcHMiLCJzdGF0ZVByb3BzIiwiZGlzcGF0Y2hQcm9wcyIsIm1lcmdlZFByb3BzIiwiaGFuZGxlRmlyc3RDYWxsIiwiZmlyc3RTdGF0ZSIsImZpcnN0T3duUHJvcHMiLCJoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlIiwiZGVwZW5kc09uT3duUHJvcHMiLCJoYW5kbGVOZXdQcm9wcyIsImhhbmRsZU5ld1N0YXRlIiwibmV4dFN0YXRlUHJvcHMiLCJzdGF0ZVByb3BzQ2hhbmdlZCIsImhhbmRsZVN1YnNlcXVlbnRDYWxscyIsIm5leHRTdGF0ZSIsIm5leHRPd25Qcm9wcyIsInByb3BzQ2hhbmdlZCIsInN0YXRlQ2hhbmdlZCIsInB1cmVGaW5hbFByb3BzU2VsZWN0b3IiLCJmaW5hbFByb3BzU2VsZWN0b3JGYWN0b3J5IiwiaW5pdE1hcFN0YXRlVG9Qcm9wcyIsImluaXRNYXBEaXNwYXRjaFRvUHJvcHMiLCJpbml0TWVyZ2VQcm9wcyIsIm9wdGlvbnMiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJhY3Rpb25DcmVhdG9ycyIsImJvdW5kQWN0aW9uQ3JlYXRvcnMiLCJrZXkiLCJhY3Rpb25DcmVhdG9yIiwiYXJncyIsImlzUGxhaW5PYmplY3QiLCJvYmoiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiYmFzZVByb3RvIiwidmVyaWZ5UGxhaW5PYmplY3QiLCJ2YWx1ZSIsIndyYXBNYXBUb1Byb3BzQ29uc3RhbnQiLCJnZXRDb25zdGFudCIsImluaXRDb25zdGFudFNlbGVjdG9yIiwiY29uc3RhbnQiLCJjb25zdGFudFNlbGVjdG9yIiwiZ2V0RGVwZW5kc09uT3duUHJvcHMiLCJtYXBUb1Byb3BzIiwiQm9vbGVhbiIsImxlbmd0aCIsIndyYXBNYXBUb1Byb3BzRnVuYyIsImluaXRQcm94eVNlbGVjdG9yIiwicHJveHkiLCJtYXBUb1Byb3BzUHJveHkiLCJzdGF0ZU9yRGlzcGF0Y2giLCJkZXRlY3RGYWN0b3J5QW5kVmVyaWZ5IiwicHJvcHMiLCJjcmVhdGVJbnZhbGlkQXJnRmFjdG9yeSIsImFyZyIsIndyYXBwZWRDb21wb25lbnROYW1lIiwibWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yeSIsIm1hcFN0YXRlVG9Qcm9wc0ZhY3RvcnkiLCJkZWZhdWx0TWVyZ2VQcm9wcyIsIndyYXBNZXJnZVByb3BzRnVuYyIsImluaXRNZXJnZVByb3BzUHJveHkiLCJhcmVNZXJnZWRQcm9wc0VxdWFsIiwiaGFzUnVuT25jZSIsIm1lcmdlUHJvcHNQcm94eSIsIm5leHRNZXJnZWRQcm9wcyIsIm1lcmdlUHJvcHNGYWN0b3J5IiwiZGVmYXVsdE5vb3BCYXRjaCIsImNhbGxiYWNrIiwiY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uIiwiZmlyc3QiLCJsYXN0IiwiY2xlYXIiLCJub3RpZnkiLCJsaXN0ZW5lciIsIm5leHQiLCJsaXN0ZW5lcnMiLCJwdXNoIiwic3Vic2NyaWJlIiwiaXNTdWJzY3JpYmVkIiwicHJldiIsInVuc3Vic2NyaWJlIiwibnVsbExpc3RlbmVycyIsImNyZWF0ZVN1YnNjcmlwdGlvbiIsInBhcmVudFN1YiIsInN1YnNjcmlwdGlvbnNBbW91bnQiLCJzZWxmU3Vic2NyaWJlZCIsInRyeVN1YnNjcmliZSIsImNsZWFudXBMaXN0ZW5lciIsInJlbW92ZWQiLCJ0cnlVbnN1YnNjcmliZSIsIm5vdGlmeU5lc3RlZFN1YnMiLCJoYW5kbGVDaGFuZ2VXcmFwcGVyIiwib25TdGF0ZUNoYW5nZSIsInRyeVN1YnNjcmliZVNlbGYiLCJ0cnlVbnN1YnNjcmliZVNlbGYiLCJnZXRMaXN0ZW5lcnMiLCJjYW5Vc2VET00iLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwiaXMiLCJ4IiwieSIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzIiwia2V5c0IiLCJpIiwiUkVBQ1RfU1RBVElDUyIsImNoaWxkQ29udGV4dFR5cGVzIiwiY29udGV4dFR5cGUiLCJjb250ZXh0VHlwZXMiLCJkZWZhdWx0UHJvcHMiLCJnZXREZWZhdWx0UHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJtaXhpbnMiLCJwcm9wVHlwZXMiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiY2FsbGVlIiwiYXJndW1lbnRzIiwiYXJpdHkiLCJGT1JXQVJEX1JFRl9TVEFUSUNTIiwicmVuZGVyIiwiTUVNT19TVEFUSUNTIiwiY29tcGFyZSIsIlRZUEVfU1RBVElDUyIsImdldFN0YXRpY3MiLCJjb21wb25lbnQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJvYmplY3RQcm90b3R5cGUiLCJob2lzdE5vblJlYWN0U3RhdGljcyIsInRhcmdldENvbXBvbmVudCIsInNvdXJjZUNvbXBvbmVudCIsImluaGVyaXRlZENvbXBvbmVudCIsImNvbmNhdCIsInRhcmdldFN0YXRpY3MiLCJzb3VyY2VTdGF0aWNzIiwiZGVzY3JpcHRvciIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwiaW5pdGlhbGl6ZUNvbm5lY3QiLCJOT19TVUJTQ1JJUFRJT05fQVJSQVkiLCJzdHJpbmdpZnlDb21wb25lbnQiLCJDb21wIiwiSlNPTiIsInN0cmluZ2lmeSIsImVyciIsIlN0cmluZyIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyIsImVmZmVjdEZ1bmMiLCJlZmZlY3RBcmdzIiwiZGVwZW5kZW5jaWVzIiwiY2FwdHVyZVdyYXBwZXJQcm9wcyIsImxhc3RXcmFwcGVyUHJvcHMiLCJsYXN0Q2hpbGRQcm9wcyIsInJlbmRlcklzU2NoZWR1bGVkIiwid3JhcHBlclByb3BzIiwiY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSIsInN1YnNjcmliZVVwZGF0ZXMiLCJzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMiLCJjaGlsZFByb3BzU2VsZWN0b3IiLCJpc01vdW50ZWQiLCJhZGRpdGlvbmFsU3Vic2NyaWJlTGlzdGVuZXIiLCJkaWRVbnN1YnNjcmliZSIsImxhc3RUaHJvd25FcnJvciIsImNoZWNrRm9yVXBkYXRlcyIsImxhdGVzdFN0b3JlU3RhdGUiLCJuZXdDaGlsZFByb3BzIiwidW5zdWJzY3JpYmVXcmFwcGVyIiwic3RyaWN0RXF1YWwiLCJoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRQdXJlT3B0aW9uIiwiY29ubmVjdCIsInB1cmUiLCJmb3J3YXJkUmVmIiwiQ29udGV4dCIsIndyYXBXaXRoQ29ubmVjdCIsIldyYXBwZWRDb21wb25lbnQiLCJpc1ZhbGlkIiwic2VsZWN0b3JGYWN0b3J5T3B0aW9ucyIsIkNvbm5lY3RGdW5jdGlvbiIsInByb3BzQ29udGV4dCIsInJlYWN0UmVkdXhGb3J3YXJkZWRSZWYiLCJ1c2VNZW1vIiwicmVhY3RSZWR1eEZvcndhcmRlZFJlZjIiLCJ3cmFwcGVyUHJvcHMyIiwiQ29udGV4dFRvVXNlIiwiUmVzdWx0Q29udGV4dCIsIkNvbnN1bWVyIiwiZGlkU3RvcmVDb21lRnJvbVByb3BzIiwiZGlkU3RvcmVDb21lRnJvbUNvbnRleHQiLCJzdWJzY3JpcHRpb24yIiwibm90aWZ5TmVzdGVkU3ViczIiLCJiaW5kIiwib3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSIsImlzUHJvY2Vzc2luZ0Rpc3BhdGNoIiwibGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciIsImFjdHVhbENoaWxkUHJvcHNTZWxlY3RvciIsInN1YnNjcmliZUZvclJlYWN0IiwicmVhY3RMaXN0ZW5lciIsImFjdHVhbENoaWxkUHJvcHMiLCJyZW5kZXJlZFdyYXBwZWRDb21wb25lbnQiLCJyZWYiLCJyZW5kZXJlZENoaWxkIiwiUHJvdmlkZXIiLCJfQ29ubmVjdCIsIm1lbW8iLCJDb25uZWN0IiwiX2ZvcndhcmRlZCIsImZvcndhcmRDb25uZWN0UmVmIiwiZm9yd2FyZGVkIiwiY29ubmVjdF9kZWZhdWx0IiwiY2hpbGRyZW4iLCJzZXJ2ZXJTdGF0ZSIsInByZXZpb3VzU3RhdGUiLCJQcm92aWRlcl9kZWZhdWx0IiwiY3JlYXRlU3RvcmVIb29rIiwidXNlU3RvcmUyIiwidXNlU3RvcmUiLCJjcmVhdGVEaXNwYXRjaEhvb2siLCJ1c2VEaXNwYXRjaDIiLCJ1c2VEaXNwYXRjaCIsImJhdGNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-redux/dist/react-redux.mjs\n");

/***/ })

};
;